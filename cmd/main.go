package main

import (
	"math"
	"net/http"
	"regexp"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
)

type Receipt struct {
	RetailerName string  `json:"retailer"`
	PurchaseDate string  `json:"purchaseDate"`
	PurchaseTime string  `json:"purchaseTime"`
	Items        []Item  `json:"items"`
	Total        float64 `json:"total,string"`
}

type Item struct {
	Description string  `json:"shortDescription"`
	Price       float64 `json:"price,string"`
}

type ReceiptResponse struct {
	ID string `json:"id"`
}

type PointsResponse struct {
	Points int `json:"points"`
}

// Map to store receipts with their IDs, using in place of DB
var receipts map[string]Receipt

func main() {
	receipts = make(map[string]Receipt)

	app := gin.Default()

	app.GET("/receipts/:id/points", getPoints)
	app.POST("/receipts/process", processReceipt)

	app.Run()
}

/*
Takes in a JSON receipt (see example in the example directory) and returns a JSON object with an ID generated by your code.
*/
func processReceipt(c *gin.Context) {
	var receipt Receipt

	// Basic error
	if err := c.ShouldBindJSON(&receipt); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Generate unique ID using Google uuid generator
	id := uuid.New().String()

	// Store receipt with generated ID
	receipts[id] = receipt

	// Return ID in response
	c.JSON(http.StatusCreated, ReceiptResponse{ID: id})
}

/*
A simple Getter endpoint that looks up the receipt by the ID and returns an object specifying the points awarded.
*/
func getPoints(c *gin.Context) {
	id := c.Param("id")
	receipt, ok := receipts[id]
	if !ok {
		c.JSON(http.StatusNotFound, gin.H{"error": "Receipt not found"})
		return
	}

	points := calculatePoints(&receipt)
	c.JSON(http.StatusOK, PointsResponse{Points: points})
}

/*
Function to calculate points
*/
func calculatePoints(receipt *Receipt) int {
	points := 0

	// One point for every alphanumeric character in the retailer name.
	retailerNamePoints := countAlphanumeric(receipt.RetailerName)
	// fmt.Println("Retailer name: ", retailerNamePoints)
	points += retailerNamePoints

	// 50 points if the total is a round dollar amount with no cents.
	if receipt.Total == math.Round(receipt.Total) {
		// fmt.Println("Is round dollar: 50")
		points += 50
	}

	// 25 points if the total is a multiple of 0.25.
	if math.Mod(receipt.Total, 0.25) == 0 {
		// fmt.Println("Is multiple of 0.25: 25")
		points += 25
	}

	// 5 points for every two items on the receipt.
	itemPoints := (len(receipt.Items) / 2) * 5
	// fmt.Println("5 points for every two items: ", itemPoints)
	points += itemPoints

	// If the trimmed length of the item description is a multiple of 3,
	// multiply the price by 0.2 and round up to the nearest integer.
	// The result is the number of points earned.
	for _, item := range receipt.Items {
		// Remove leading and trailing spaces
		trimmedLength := len(strings.Trim(item.Description, " \t\n\r"))
		if trimmedLength%3 == 0 {
			itemPoints := int(math.Ceil(item.Price * 0.2))
			// fmt.Printf("Is multiple of 3 (Description: %s) = %d\n", item.Description, itemPoints)
			points += itemPoints
		}
	}

	// 6 points if the day in the purchase date is odd.
	if isDayOdd(receipt.PurchaseDate) {
		// fmt.Println("Purchase date is odd: 6")
		points += 6
	}

	// 10 points if the time of purchase is after 2:00pm and before 4:00pm.
	if isTimeInRange(receipt.PurchaseTime) {
		// fmt.Println("Purchase time between 2 & 4: 10")
		points += 10
	}

	return points
}

/*
Helper function for finding alphanumeric chars
*/
func countAlphanumeric(input string) int {
	// Regular expression pattern for alphanumeric characters
	pattern := "[a-zA-Z0-9]"
	regex := regexp.MustCompile(pattern)

	// Use the FindAllString method to find all alphanumeric characters in the input
	matches := regex.FindAllString(input, -1)

	// Return the count of alphanumeric characters
	return len(matches)
}

/*
Helper function for checking if day is odd
*/
func isDayOdd(dateString string) bool {
	// Parse the date string into a time.Time value
	purchaseDate, err := time.Parse("2006-01-02", dateString)
	if err != nil {
		// fmt.Println("Error parsing date:", err)
		return false
	}

	// Get the day of the month
	day := purchaseDate.Day()
	// fmt.Println("Day is: ", day)

	// Check if the day is odd
	return day%2 == 1
}

/*
Helper function to check if time is within designated range
*/
func isTimeInRange(timeString string) bool {
	// Parse the time string into a time.Time value
	purchaseTime, err := time.Parse("15:04", timeString)
	if err != nil {
		// fmt.Println("Error parsing time:", err)
		return false
	}
	// fmt.Println("Time is: ", purchaseTime)

	// Designating year month and date because time.Parse automatically adds
	// 0000-1-1 if not designated such as our input
	startTime := time.Date(0000, 1, 1, 14, 0, 0, 0, time.UTC) // 2:00 PM
	endTime := time.Date(0000, 1, 1, 16, 0, 0, 0, time.UTC)   // 4:00 PM

	// Check if parsed time is after 2:00 PM and before 4:00 PM
	return purchaseTime.After(startTime) && purchaseTime.Before(endTime)
}
